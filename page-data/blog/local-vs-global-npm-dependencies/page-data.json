{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/local-vs-global-npm-dependencies/","result":{"data":{"site":{"siteMetadata":{"title":"XKoji.dev","siteUrl":"https://xkoji.dev"}},"markdownRemark":{"id":"e3f4ae42-108b-5a0c-a23e-85851315181f","excerpt":"Working on Node.js based applications usually requires you to install dependencies that are needed to provide functionality within the project, either forâ€¦","html":"<p>Working on Node.js based applications usually requires you to install dependencies that are needed to provide functionality within the project, either for development or as part of the project logic at runtime. A number of the development dependencies provide a command line interface for interacting with the package and making use of the functionality for things like scaffolding, compiling, bundling, publishing, etc.</p>\n<p>For these CLI-based dependencies, the author usually recommends installing the packages globally, for ease of use. However there are benefits to installing these dependencies locally instead of globally, which might not be immediately obvious.</p>\n<h3>All project dependencies declared in a single place</h3>\n<p>Whenever you install local dependencies, they are listed in the package.json file which acts as a manifest showing all the information about a package, including the dependencies it needs. This means if you install your global dependencies locally, it becomes obvious what all the dependencies of the project are.</p>\n<p>For instance, assuming you have a project that uses typescript, you can install the typescript CLI package globally (<code class=\"language-text\">yarn global add typescript</code>) and call <code class=\"language-text\">tsc path/to/project</code> whenever you want to compile the code. Now you might even add a script in the package.json file for this, so itâ€™s more obvious to you and any other people working on the project what command to run to compile.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compile\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"tsc .\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>However imagine you decide to work on this project on another computer, or some other person tries to work on the same project in their own machine. After installing the dependencies (<code class=\"language-text\">yarn install</code>), running the compile script would fail on the first attempt because yarn canâ€™t find the <code class=\"language-text\">tsc</code> command. You then need to install typescript globally on that machine as well to continue working on the project. Now imagine typescript now has several major updates and now the latest version is not backward compatible with the version of typescript used in the project initially. You would get another error and would have to start troubleshooting to figure out what exact version of typescript you need to install to get this working.</p>\n<p>On the other hand, installing the <code class=\"language-text\">typescript</code> package as a local dependency (<code class=\"language-text\">yarn add --dev typescript</code>) would mean, any one that runs <code class=\"language-text\">yarn install</code> in that project would also install typescript automatically (and the right version as well), and the compile script would just work as expected.</p>\n<h3>Multiple projects with different versions on same machine</h3>\n<p>As a developer working on Node.js based projects, you likely have multiple projects on your local machine that you work on at different times. Assuming several of these projects use typescript, and you install typescript globally. You worked on project X a couple of months back when typescript was at version 2.7.1. You havenâ€™t worked on it in a while.</p>\n<p>You get started working on another project Y that uses the latest stack features (react hooks, latest typescript esnext features, bells and whistles). Project Y needs at least typescript@3.8.3 for it to compile properly. You try compiling the project and you get an error because typescript doesnâ€™t understand the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator\">nullish coalescing operator</a>. Now youâ€™re wondering why this project worked in your colleagueâ€™s machine but isnâ€™t working on yours. After a couple of hours debugging, you realize your global typescript version is at 2.7.1. You decide to update the global typescript package. Project Y compiles! Thatâ€™s great news.</p>\n<p>Things move along quickly and now you have some tasks to implement in Project X. You open it up in your editor, make the changes and compile. Now there are several typescript linting errors that werenâ€™t there before. You only changed 2 lines of code but typescript isnâ€™t compiling because of errors in an entirely different file you didnâ€™t touch. After several hours of debugging, you realize that you are using typescript@3.8.3 but the project was built with typescript@2.7.1. You now have two choices: forcefully fix the code and update it to use the latest version of typescript, or you downgrade typescript to 2.7.1. You quickly figure out that none of these options is good enough ðŸ˜ž</p>\n<p>Imagine the same scenario but you are using a locally installed typescript dependency in both Project X and Project Y. You wouldnâ€™t have any of the issue above because each project would have its own version of typescript to work with, without affecting the other project.</p>\n<h2>Using local dependencies from CLI</h2>\n<p>One of the advantages you would usually see with global dependencies over local dependencies is that: you can just call the command of a global dependency from the command line, but you canâ€™t do the same with local dependencies. Using the previous example of typescript. If you installed typescript globally, you can just run the following from anywhere and it would work:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ tsc /path/to/project</code></pre></div>\n<p>You canâ€™t do the same with local dependencies. However if you manage your dependencies with <a href=\"https://yarnpkg.com/\">yarn</a>, you can run a local command in a similar way with yarn. The equivalent of that command would be:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">$ <span class=\"token function\">yarn</span> tsc <span class=\"token builtin class-name\">.</span></code></pre></div>\n<p>However, you need to run this command from within the project working directory for yarn to be able to find the local dependency to run.</p>\n<p>In my personal opinion, this is a relatively small issue that can be worked around compared to the benefits of local dependencies.</p>\n<p>You also have the option of adding the command as a script in the package.json file, in which case you can run it with both yarn and npm.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"compile\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"tsc\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You can run it using <code class=\"language-text\">yarn compile</code> or <code class=\"language-text\">npm run compile</code>. This would execute the <code class=\"language-text\">tsc</code> command from the local dependencies of the project, if available.</p>\n<h2>When to use global dependencies</h2>\n<p>While I generally recommend using local dependencies, I have to say that there are some cases where you need global dependencies.</p>\n<h3>Scaffolding the project</h3>\n<p>When you need a package to scaffold a project, you donâ€™t have a project yet and so no package.json file to have local dependencies in. In such cases, you need to install the packages as a global dependency. Examples of these are: angular CLI for scaffolding angular projects (<code class=\"language-text\">ng new project-name</code>), create-react-app for scaffolding react projects (<code class=\"language-text\">create-react-app project-name</code>), vue CLI for scaffolding Vue.js applications (<code class=\"language-text\">vue create project-name</code>), and the many others. These commands create the project directory as well as creating the package.json file and installing the dependencies for you. Usually they would install the dependencies locally as well for scaffolding other part of the project (like components, routing, styles, etc) so you donâ€™t depend on the global dependency for that.</p>\n<h3>Running task-specific, project-agnostic commands</h3>\n<p>There are a number of dependencies that are used to perform tasks that are not specific to any project. These commands are similar in function to the other commands you have available to you in the command line. They provide utilities that can be used in a wide range of cases. For example, starting up a simple local server with <a href=\"https://www.npmjs.com/package/serve\"><code class=\"language-text\">serve</code></a>, getting help about other commands with <a href=\"https://www.npmjs.com/package/tldr\"><code class=\"language-text\">tldr</code></a>, and many others. These commands provide general utility functionality and as such are better off installed globally.</p>\n<h2>Bonus tip: using <code class=\"language-text\">npx</code> or <code class=\"language-text\">yarn dlx</code> for one-time global packages</h2>\n<p>Like I mentioned above, there are times when you need to install packages globally. However, there are some packages that you donâ€™t need to keep installed always, especially if you just need to run the command once as opposed to using it frequently. Examples of such packages would be the scaffolding packages and some others (like starting up a local server). Depending on the kind of tasks you work on, these are not packages you might need to have installed on your machine always. More often than not, you just scaffold a project one time and proceed with developing the project without needing the scaffolding functionality afterwards.</p>\n<p>For these cases, you can make use of the <code class=\"language-text\">npx</code> command (provided by npm), or the <code class=\"language-text\">yarn dlx</code> command (available in <strong>yarn v2</strong>, not yarn v1). For example if you wanted to scaffold a react app, you can run <code class=\"language-text\">npx create-react-app project-name</code> or <code class=\"language-text\">yarn dlx create-react-app project-name</code> and this would temporarily download the <code class=\"language-text\">create-react-app</code> dependency and execute the command to scaffold the project, without installing the package globally in your machine.</p>\n<h3>Conclusion</h3>\n<p>Preferring locally installed dependencies over global dependencies provide a number of benefits that would be helpful as the number of projects and complexity of the projects increases. Also consider executing the dependencies without installing them using <code class=\"language-text\">npx</code> or <code class=\"language-text\">yarn dlx</code>.</p>","frontmatter":{"title":"Local vs global npm dependencies","date":"May 04, 2020","description":""}}},"pageContext":{"slug":"/blog/local-vs-global-npm-dependencies/","previous":{"fields":{"slug":"/blog/automate-scaffolding-processes-with-plop/"},"frontmatter":{"title":"Automate scaffolding processes with Plop"}},"next":null}}}